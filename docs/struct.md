# struct.h

## Описание структур и объявленных методов

### digit - наши цифры (определено в `structs/digit.h`)

Цифры записываются начиная с нижнего подчеркивания:
`_0, _1, _2, _3, _4, _5, _6, _7, _8, _9`.
Так можно записывать числа { _4, _2 }
Выше записано число "42".

#### Инкремент цифры

```c++
inc(digit &a, bool &overflowFlag);
```
Принимает цифру `digit &a` и флаг переполнения `bool &overflowFlag`
Значение флага `true`, если на предыдущем разряде не было переполнения (результат применения чего-то к нему меньше десяти), и `false`, если было.
Флаг переполнения необходимо передавать в качестве переменной, чтобы использовать в следующих разрядах.
Поскольку цифра и флаг передаются по ссылке, после применения функции они изменяются.
* Примеры вызова
```c++
bool overflowFlag = false;
digit a = _8;
inc(a, overflowFlag);  // a == _9; overflowFlag == false
inc(a, overflowFlag);  // a == _0; overflowFlag == true
a = _8;
overflowFlag = true;
inc(a, overflowFlag);  // a++ + 1; a == _0; overflowFlag == true
```

#### Сложение цифр

```c++ digit add(const digit &a, const digit &b, bool &overflowFlag)```
Принимает цифры `const digit &a` и `const digit &b` и уже знакомый флаг переполнения. Возвращает результат сложения цифрой. Модифицирует флаг переполнения.
* Примеры вызова
```c++
digit result;
bool overflowFlag = false;
result = add(_4, _2, overflowFlag);  // result == _6; overflowFlag == false
result = add(_4, result, overflowFlag);  // result == _0; overflowFlag == true
overflowFlag = true;
result = add(_9, _0, overflowFlag);  // 9 + 0 + 1; result == _0; 
                                     // overflowFlag == true;
```
Помимо этих функций определены умножение, разность и сравнение цифр (об этом позже)

### ordinal - сравнения (определено в `structs/ordinal.h`)

Именованные константы, возвращаемые функцией  `COM_NN_D`
```c++
ordinal::LT  // Меньше
ordinal::GT  // Больше
ordinal::EQ  // Равно
```

### IntegerState - состояние целого (определено в `structs/state.h`)

Именованные константы, возвращаемые функцией `POZ_Z_D`
```c++
IntegerState::Zero  // Ноль
IntegerState::Positive  // Положительно
IntegerState::Negative  // Отрицательно
```

### natural - натуральные числа (определено в `structs/struct.h`)

Представляют собой упорядоченный набор цифр.
Доступ к цифрам осуществляется по индексу:
```c++
natural n;  // n == 0 <=> n[0] == _0
n[0] = _3;  // Теперь n это _3
n[2] = _1;  // После этого n стало представлять число 103
```
Как можно заметить, недостающие разряды добавляются автоматически, что дает возможность обратиться к несуществующим разрядам (число само дополнит их незначащими нулями до требуемого вами)
**Важный момент:** цифры хранятся от младшего разряда к старшему. Таким образом число 9426 хранится как [ 6, 2, 4, 9 ], т.е. по индексу 0 лежит _9

#### Инициализация чисел

```c++
natural a;    // или
natural a();  // a == 0 <=> a.digits[0] == _0

natural a(b)  // a == b Копирует b в a
natural a = {_9, _4, _2, _6}  // a == 9426
natural a("9426");  // a == 9426
```

#### Определение порядка

```c++
natural a = {_9, _4, _2, _6}  // a == 9426
a.order();  // 4
natural b;  // b == 0
b.order();  // 0
natural c(1);  // c == 1
c.order();  // 1
```

#### Избавление от незначащих нулей

```c++
natural a;
/*some code*/  // a == 00042
a.reduce();  // a == 42
```

#### Количество значащих разрядов

```c++
natural a("6390");
a.order();  // 4
```

### integer - целые числа (определено в `structs/struct.h`)

Представляют собой натуральное число `module` и логическое значение `isPositive`

#### Инициализация целых

```c++
integer a;  // a.module == 0; a.isPositive == true
integer b(-42);  // b.module == 42; b.isPositive == false
integer c("-00023");  // c.module == 23; c.isPositive == false
```

### fraction - рациональные числа (определено в `structs/struct.h`)

Представляют собой целый числитель `numerator` и натуральный знаменатель `denominator`

#### Инициализация рациональных

```c++
fraction a;  // a.numerator == 0; a.denominator == 1
fraction b(-23);  // b.numerator == -23; b.denominator == 1
```

### polynom - многочлены с рациональными коэффициентами (определено в `structs/struct.h`)

Представляют собой вектор рациональных коэффициентов в порядке увеличения степени, т.е. 18x^3 + 4x^2 + 3 ≡ { 3, 0, 4, 18 }.
>Обращение по индексу работает так же как и для натуральных чисел

#### Инициализация

```c++
polynom a;  // a == 0
polynom b( { 8, 4, 0, 3 } );  // b == 8x^3 + 4x^2 + 3
polynom c = b;  // c == 8x^3 + 4x^2 + 3
```

#### Избавление от незначащих разрядов

```c++
polynom a;
/*some code*/  // a == 0x^6 + 0x^5 + 0x^4 + 2x^3 + 16x^2 + 0x + 2
a.reduce();  // a == 2x^3 + 16x^2 + 0x + 2
```

## Также в `structs/operators.h` определены операторы передачи в поток

```c++
natural a("42");
std::cout << a;  // 42
```
