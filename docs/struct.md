# struct.h
### Описание структур и объявленных методов

#### digit - наши цифры (определено в `stricts/digit.h`)
Цифры записываются начиная с нижнего подчеркивания: 
`_0, _1, _2, _3, _4, _5, _6, _7, _8, _9`.
Так можно записывать числа { _4, _2 } (записано число "42").

##### Инкримент цифры (определено в `stricts/digit.h`)
```c++
inc(digit &a, bool &overflowFlag);
```
Принимает цифру `digit &a` и флаг переполнения `bool &overflowFlag`
Значение флага `true`, если на предыдущем разряде не было переполнения (результат применения чего-то к нему меньше десяти), и `false`, если было.
Флаг переполнения необходимо передавать в качестве переменной, чтобы использовать в следующих разрядах.
Поскольку цифра и флаг передаются по ссылке, после применения функции они изменяются.
* Примеры вызова

```c++
bool overflowFlag = false;
digit a = _8;
inc(a, overflowFlag);  // a == _9; overflowFlag == false
inc(a, overflowFlag);  // a == _0; overflowFlag == true
a = _8;
overflowFlag = true;
inc(a, overflowFlag);  // a++ + 1; a == _0; overflowFlag == true
```
##### Сложение цифр (определено в `stricts/digit.h`)
```c++ digit add(const digit &a, const digit &b, bool &overflowFlag)```
Принимает цифры `const digit &a` и `const digit &b` и уже знакомый флаг переполнения. Возврощает результат сложения цифрой. Модифицирует флаг переполнения.
* Примеры вызова

```c++
digit result;
bool overflowFlag = false;
result = add(_4, _2, overflowFlag);  // result == _6; overflowFlag == false
result = add(_4, result, overflowFlag);  // result == _0; overflowFlag == true
overflowFlag = true;
result = add(_9, _0, overflowFlag);  // 9 + 0 + 1; result == _0; 
                                     // overflowFlag == true;
```
Помимо этих функций определено умножение, разность и сравнение цифр (об этом позже)
### natural - натуральные числа
Представляет собой упорядоченный набор цифр.
Доступ к цифрам осуществляется по индексу:
```c++
natural n;  // n == 0 <=> n[0] == _0
n[0] = _3;  // Теперь n это _3
n[2] = _1;  // После этого n стало представлять число 103
```
Как можно заметить, недостающие разряды сами добавляются, что дает возможность обратится к несуществующим разрядам (число само дополнит их незначащими нулями до треуемого вами)
**Важный момент:** цифры хранятся от младшего разряда к старшему. Таким образом число 9426 хранится как [ 6, 2, 4, 9 ], т.е. по индексу 0 лужит _9
#### Инициализация чисел
```c++
natural a;    // или
natural a();  // a == 0 <=> a.digits[0] == _0

natural a(b)  // a == b Копирует b в a
natural a = {_9, _4, _2, _6}  // a == 9426
```
Позже будет возможность строить числа по строке (к примеру `natural n("42")`)
#### Определение порядка ~~(на данный момент забагованно)~~ (пофикшено в ebe5c55)
```c++
a = {_9, _4, _2, _6}  // a == 9426
a.order()  // Должно вернуть 4
```
